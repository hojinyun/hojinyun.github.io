---
title:  "#17413: 단어 뒤집기 2"
categories: [Algorithm & Data Structure]
tags: [Data Structure, Stack]
---

[백준 17413번: 단어 뒤집기 2](https://www.acmicpc.net/problem/17413)

## 문제:

문자열 S가 주어졌을 때, 이 문자열에서 단어만 뒤집으려고 한다.

먼저, 문자열 S는 아래와과 같은 규칙을 지킨다.

1. 알파벳 소문자('`a`'-'`z`'), 숫자('`0`'-'`9`'), 공백(' ``'), 특수 문자('`<`', '`>`')로만 이루어져 있다.
2. 문자열의 시작과 끝은 공백이 아니다.
3. '`<`'와 '`>`'가 문자열에 있는 경우 번갈아가면서 등장하며, '`<`'이 먼저 등장한다. 또, 두 문자의 개수는 같다.

태그는 '`<`'로 시작해서 '`>`'로 끝나는 길이가 3 이상인 부분 문자열이고, '`<`'와 '`>`' 사이에는 알파벳 소문자와 공백만 있다. 단어는 알파벳 소문자와 숫자로 이루어진 부분 문자열이고, 연속하는 두 단어는 공백 하나로 구분한다. 태그는 단어가 아니며, 태그와 단어 사이에는 공백이 없다.

## 입력:

첫째 줄에 문자열 S가 주어진다. S의 길이는 100,000 이하이다.

## 풀이:

이 문제는 [#9093:단어 뒤집기](/algorithm%20&%20data%20structure/9093-단어-뒤집기/) 문제와 똑같이 풀면 되는데 태그인 경우에는 빼주면 된다. 따라서 몇 개의 조건문만 추가해주면 된다.

1. 우선 현재 출력 해야 되는 문자가 tag인지 아닌지 구분하기 위해 boolean 변수를 만들어준다.
2. 우선 태그 안쪽인지 아닌지 앞서 만든 bool 변수를 이용하여 if문으로 [#9093:단어 뒤집기](/algorithm%20&%20data%20structure/9093-단어-뒤집기/)에서 구현한 뒤집기를 감싸준다. 추가로 ‘<’ 문자열도 공백과 같은 취급을 해주어야 뒤집히기 때문에 ‘<’ 문자열일 경우에도 전에 있던 단어들을 뒤집어 주며 ‘<’ 문자일 경우는 tag를 true로 바꿔준다.
    1. 처음 풀 때는 ‘<’ 전 단어들을 뒤집어 줘야 된다는 생각을 못하고 그냥 실행 하였더니 태그 시작과 붙어 있던 단어가 태그가 끝난 뒤 뒤집혀서 출력 되는 경우가 생겨서 추가 했다.
    
    ⭐이 처럼 문제를 풀 때는 보자 마자 모든 것이 바로 생각나서 구현 하는 것이 아닌 “대충 이렇게 구현하면 되지 않을까”하고 해본 뒤 생각 못한 버그가 발생하면 그때 고치는 방식으로 풀면 된다.
    

### 코드:

```cpp
#include <iostream>
#include <stack>
#include <string>
using namespace std;
int main() {
    string original = "";
    bool tag = false;
    getline(cin, original);
    //마지막 단어도 뒤집어주기 위해 마지막 줄에 공백 추가 
    original += ' ';
    stack<char> str; 
    for (int i = 0; i < original.size(); i++) {
			//태그 아니니까 뒤집기 
			if(!tag){
				//공백 보이면 단어 순서 거꾸로 출력
		        if (original[i] == ' '|| original[i] == '<') {
		        	if(original[i] == '<') tag = true; //tag 안에 들어온걸 명시 
		        	
		            while (!str.empty()) {
		                cout << str.top();
		                str.pop();
		            }
		            cout << original[i]; //공백 출력 
		        }
				//공백 아니면 스택에 집어 넣기 
		        else str.push(original[i]);
			}
			//괄호 안 이니까 그대로 출력 
			else{
				if(original[i] == '>') tag = false;
				cout << original[i];
			}
    }
}
```
