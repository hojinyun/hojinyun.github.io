---
title:  "#2178: 미로 탐색"
categories: [Algorithm & Data Structure]
tags: [Data Structure, Graph]
---

[백준 2178번: 미로 탐색](https://www.acmicpc.net/problem/2178)

## 문제:

N×M크기의 배열로 표현되는 미로가 있다.

미로에서 1은 이동할 수 있는 칸을 나타내고, 0은 이동할 수 없는 칸을 나타낸다. 이러한 미로가 주어졌을 때, (1, 1)에서 출발하여 (N, M)의 위치로 이동할 때 지나야 하는 최소의 칸 수를 구하는 프로그램을 작성하시오. 한 칸에서 다른 칸으로 이동할 때, 서로 인접한 칸으로만 이동할 수 있다.

위의 예에서는 15칸을 지나야 (N, M)의 위치로 이동할 수 있다. 칸을 셀 때에는 시작 위치와 도착 위치도 포함한다.

## 입력:

첫째 줄에 두 정수 N, M(2 ≤ N, M ≤ 100)이 주어진다. 다음 N개의 줄에는 M개의 정수로 미로가 주어진다. 각각의 수들은 **붙어서** 입력으로 주어진다.

## 풀이:

- 처음 이 문제를 풀 때는 dfs와 bfs 어떤 걸 사용해도 상관 없다고 생각 했는데 dfs를 사용하면 비효율적일 것 같아 bfs로 풀었다. 나중에 찾아보니 dfs로 풀면 시간 초과로 오답 처리 된다고 한다. dfs가 비효율적일 것 같았던 이유는 dfs로 푸는 방식은 모든 경로를 다 확인한 뒤 그 중 최소값을 찾아야 되는 방식인데 그렇게 풀면 제일 처음 목적지에 도달하는 경로가 최단 경로인 bfs 방식보다 연산 횟수가 훨씬 많을 것이기 때문이다.
- 우선 탐색 문제는 항상 두가지 배열이 필요하다. 방문 확인을 위한 배열과 그래프를 저장하기 위한 배열이다. 그래프를 저장하기 위한 배열이 char로 저장 된 이유는 입력값이 붙어 있기 때문에 int 자료형일 경우에는 숫자 전체를 저장해버리기 때문이다. 방분 확인을 위한 배열이 bool이 아니고 int자료형인 이유는 이 문제에서는 그래프의 깊이 즉 최단 경로의 거리를 알아야 되기 때문에 int자료형을 사용하였다. 방문 확인용 배열에는 깊이 값을 저장해줌과 동시에 0만 아니면 방문하였다는 것이기 때문에 방문 확인도 가능하다.
- 우선 입력값을 받은 뒤 시작점을 큐에 넣어 준 뒤 while문에서 bfs를 시작한다. bfs는 항상 큐 앞에 값을 빼주면서 그 값을 활용하여 또 다른 값들을 큐를 넣어주는 방식을 사용한다. 큐 앞에서 뺀 값의 4가지 방향을 모두 확인 해준 뒤 갈 수 있는 곳이면 해당 좌표를 큐에 저장 해주면서 깊이 저장 함수에 이전 좌표에 +1 더하여 깊이를 기록 해준다. while문이 끝난 뒤에는 도착점 좌표에 저장 된 깊이를 출력해주면 최단 길이가 나온다.

### 코드:

```cpp
#include <iostream>
#include <queue>

using namespace std;

int n, m; //가로 세로 길이
int check[100][100]={0}; //깊이 저장 및 방문 확인 을 위한 배열
char map[100][100]={0}; //지도
queue<pair<int,int>> q; //dfs를 위한 큐
//이동 가능한 4방향
int dx[4] = {0,0,1,-1};
int dy[4]={1,-1,0,0};

int main(){
	//입력 
	cin >> n >> m; 
	for(int i = 0; i < n; i++) cin >> map[i];
	//주위 4칸을 모두 확인하는 dfs 시작
	//시작점 저장
	q.push({0,0});
	check[0][0] = 1;
	while(!q.empty()){
		pair<int,int> tmp = q.front(); //큐 제일 앞에 값 저장
		q.pop(); //큐 제일 앞에 값 삭제
		for(int i = 0; i < 4; i++){
			int row = tmp.first+dx[i], col = tmp.second + dy[i];
			//이동하려는 값이 범위 밖이거나 방문하였으면 다음 방향으로 넘어감
			if(row<0 || row>=n || col<0 || col>=m || check[row][col])  continue;
			//이동하려는 값이 이동할 수 있는 칸인 경우 큐에 값 저장 및 배열에 깊이 저장
			if(map[row][col]=='1'){
				q.push({row,col});
				check[row][col]=check[tmp.first][tmp.second]+1;
			}
		}
	}
	//출력 
	cout<< check[n-1][m-1];
}
```