---
title:  "#6588: 골드바흐의 추측"
categories: [Algorithm & Data Structure]
tags: Math
---

[백준 6588번: 골드바흐의 추측](https://www.acmicpc.net/problem/6588)

## 문제:

1742년, 독일의 아마추어 수학가 크리스티안 골드바흐는 레온하르트 오일러에게 다음과 같은 추측을 제안하는 편지를 보냈다.

> 4보다 큰 모든 짝수는 두 홀수 소수의 합으로 나타낼 수 있다.
> 

예를 들어 8은 3 + 5로 나타낼 수 있고, 3과 5는 모두 홀수인 소수이다. 또, 20 = 3 + 17 = 7 + 13, 42 = 5 + 37 = 11 + 31 = 13 + 29 = 19 + 23 이다.

이 추측은 아직도 해결되지 않은 문제이다.

백만 이하의 모든 짝수에 대해서, 이 추측을 검증하는 프로그램을 작성하시오.

## 입력:

입력은 하나 또는 그 이상의 테스트 케이스로 이루어져 있다. 테스트 케이스의 개수는 100,000개를 넘지 않는다.

각 테스트 케이스는 짝수 정수 n 하나로 이루어져 있다. (6 ≤ n ≤ 1000000)

입력의 마지막 줄에는 0이 하나 주어진다.

## 풀이:

- 우선 수의 범위가 1,000,000을 넘어가므로 main 함수 밖에서 배열을 선언해주어야 된다. 자세한 설명은 [#17299: 오등큰수](/algorithm%20&%20data%20structure/17299-오등큰수/)에서 별표에 설명이 되어있다. 간단하게 설명하자면 1,000,000 크기 이상의 배열을 함수 안에서 선언하면 프로그램이 제대로 실행이 안된다.
- 다음으로 에라토스테네스의 체를 이용하여 소수 인덱스를 가진 값을 true로 해준다. 에라토스테네스의 체에 대한 자세한 설명은 [#1929: 소수 구하기](/algorithm%20&%20data%20structure/1929-소수-구하기/)에 되어 있다. 소수 구하기 문제와의 차이점은 i의 범위의 차이 밖에 없다.
- 이제 0이 나올 때까지 입력값을 받는다. 2부터 시작하여 입력값의 반까지 숫자를 i로 하고 for문을 돈다.
    
    🔍 입력값의 반까지만 가는 이유는 어짜피 입력 값보다 작은 값의 쌍을 합쳐서 입력 값이 나오는 경우를 구하고 있기 때문에 반까지 갔는데 합의 쌍이 없다는 것은 그 이후에도 없는 것과 같은 이유기 때문이다. 
    
- 숫자와 (입력값 - 숫자 값) 모두 소수일 경우에는 그 답을 저장하며 바로 for문에서 빠져 나온다.
    
    🔍 바로 for문에서 나오는 이유는 제일 먼저 찾은 값이 b-a 값이 가장 클 것이다. 예를 들면, (소수인 경우를 배제하고) 18인 경우에는 (1,17)이 (3,15)의 차이보다 크다. 바로 for문에서 안나오면 점점 두수가 가까워져서 b-a가 작아진다고 생각하면 편하다.
    
- (입력값 - 숫자)가 소수라는 것은 합이 n이라는 것과 두번 째 수가 소수라는 것을 동시에 증명하여 굳이 for문을 하나 더 돌면서 i+j == n인지 확인할 필요가 없다.

⭐ 이 문제를 풀 때 중요한 것은 아래의 3줄 코드다. 이 코드를 안적으면 시간초과가 떠 버린다. 이 코드를 쓰면 cin 및 cout을 사용할 때 속도가 더 올라간다고 한다. 백준에서 문제를 풀 때 입출력 관련 설명은 [이 링크](https://www.acmicpc.net/problem/15552)에 나와 있다.

```cpp
cin.tie(NULL);
cout.tie(NULL);
ios_base::sync_with_stdio(false);
```

### 코드:

```cpp
#include <iostream>
#define MAX 10000001

using namespace std;

bool prime[MAX] = {false, false};

int main(){
	//시간 초과 안되기 위한 코드
	cin.tie(NULL);
	cout.tie(NULL);
	ios_base::sync_with_stdio(false);

	int n = -1, answer_a = 0, answer_b = 0;
	//에라토스테네스의 체
	for(int i = 2; i < MAX; i++) prime[i] = true;
	for(int i = 2; i < MAX; i++){
		if(prime[i]==false) continue;
		for(int j = i+i; j < MAX; j+=i) prime[j] = false;
	}
	//소수쌍 구하기
	while(n!=0){
		cin >> n;
		if(n==0) break;
		for(int i = 2; i <= n/2; i++){
			if(prime[i] && prime[n-i]){
				answer_a = i;
				answer_b = n-i;
				break;
			}
		}
		//정답이 없을 경우 출력
		if(answer_a == 0) cout <<"Goldbach's conjecture is wrong."<< '\n';
		//정답이 있을 경우 출력
		else cout << n <<" = "<< answer_a << " + " << answer_b << '\n';
		//출력 후 정답 초기화
		answer_a = 0;
		answer_b = 0;
	}
	
}
```