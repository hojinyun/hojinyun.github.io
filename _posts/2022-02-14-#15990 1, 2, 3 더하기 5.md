---
title:  "#15990: 1, 2, 3 더하기 5"
categories: [Algorithm & Data Structure]
tags: [Dynamic Programming]
---

[백준 15990번: 1, 2, 3 더하기 5](https://www.acmicpc.net/problem/15990)

## 문제:

정수 4를 1, 2, 3의 합으로 나타내는 방법은 총 3가지가 있다. 합을 나타낼 때는 수를 1개 이상 사용해야 한다. 단, 같은 수를 두 번 이상 연속해서 사용하면 안 된다.

- 1+2+1
- 1+3
- 3+1

정수 n이 주어졌을 때, n을 1, 2, 3의 합으로 나타내는 방법의 수를 구하는 프로그램을 작성하시오.

## 입력:

첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, 정수 n이 주어진다. n은 양수이며 100,000보다 작거나 같다.

## 풀이:

- 이 문제는 [#9095: 1, 2, 3 더하기](/algorithm%20&%20data%20structure/9095-1,-2,-3-더하기)의 응용 버전이라고 할 수 있다. [#9095: 1, 2, 3 더하기](/algorithm%20&%20data%20structure/9095-1,-2,-3-더하기) 문제와는 다르게 같은 수가 반복 돼서 쓰이면 안된다는 조건이 추가 되었다. 아직 [#9095: 1, 2, 3 더하기](/algorithm%20&%20data%20structure/9095-1,-2,-3-더하기)를 안풀었다면 이 문제를 풀기 전에 풀어보는 것을 추천한다. 이 문제는 [전두선님의 블로그 포스트](https://jdselectron.tistory.com/71)를 참고하여 풀었다.
- 우선 이 문제를 풀기 위해서는 [#9095: 1, 2, 3 더하기](/algorithm%20&%20data%20structure/9095-1,-2,-3-더하기) 문제에서 앞자리를 1, 2, 3인 경우에서 그에 맞는 합이 나오도록 뒤에 숫자의 합을 저장 된 배열에서 d[n-1], d[n-2], d[n-3]과 같은 방법으로 갖고 와서 풀었는데 이 문제는 똑같으나 차원을 하나 더 추가해서 배열의 끝자리가 특정 수인 경우 그 수를 빼고 나머지 값들의 경우의 수를 세어주는 방식으로 풀면 된다.
    - 위의 예를 들어 말하면 4인 경우 우리가 구하고자 하는 것은 배열 d[4][1]+d[4][2]+d[4][3]일 것이다. 왜냐하면 끝이 1, 2, 3인 경우를 모두 더해야 4를 합으로 만드는 모든 조합을 구할 수 있기 때문이다. d[4][1]을 구하는 방법은 끝이 1이므로 우선 1을 빼주는 값들 중에 끝이 2와 3인 값을 찾아야 된다. 따라서 d[4-1][2]+d[4-1][3] = d[4][1]이 된다. 이런 식으로 쌓아 올려가면 모든 경우의 수를 저장 하여 문제를 풀 수 있다.

### 코드:

```cpp
#include <iostream>

using namespace std;

//다이나믹 프로그래밍 배열 생성 및 초기화
long long d[100001][4]={};

int main(){
	int n;
	//입력
	cin >> n;
	for(int i = 0; i < n; i++){
		int temp;
		cin >> temp;
		//Base case를 설정
		d[1][1] = d[2][2] = d[3][1] = d[3][2] = d[3][3] = 1;
		//모든 경우의 d[j][k]에서 j는 만들려고 하는 합, k는 끝에 자리
		for(int j = 4; j <= temp; j++){
			// = 기준 오른쪽 부분은 끝자리를 제외하고 남은 값들의 가능 조합의 합
			d[j][1] = (d[j-1][2]+d[j-1][3])%1000000009; 
			d[j][2] = (d[j-2][1]+d[j-2][3])%1000000009;
			d[j][3] = (d[j-3][1]+d[j-3][2])%1000000009;
 		}
		//출력
		cout << (d[temp][1] + d[temp][2] + d[temp][3])%1000000009<<'\n';
	}
}
```