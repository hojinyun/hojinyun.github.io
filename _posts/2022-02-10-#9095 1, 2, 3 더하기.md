---
title:  "#9095: 1, 2, 3 더하기"
categories: [Algorithm & Data Structure]
tags: [Dynamic Programming]
---

[백준 9095번: 1, 2, 3 더하기](https://www.acmicpc.net/problem/9095)

## 문제:

정수 4를 1, 2, 3의 합으로 나타내는 방법은 총 7가지가 있다. 합을 나타낼 때는 수를 1개 이상 사용해야 한다.

- 1+1+1+1
- 1+1+2
- 1+2+1
- 2+1+1
- 2+2
- 1+3
- 3+1

정수 n이 주어졌을 때, n을 1, 2, 3의 합으로 나타내는 방법의 수를 구하는 프로그램을 작성하시오.

## 입력:

첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, 정수 n이 주어진다. n은 양수이며 11보다 작다.

## 풀이:

- 이 문제 풀이 법은 [쟈미님의 블로그 포스트](https://jyami.tistory.com/15)를 참고하여 풀었다.
- 이 문제는 바텀업 방식으로 for문을 사용하여 문제를 풀었다. 바텀업 방식을 모른다면 [Dynamic Programming(동적 프로그래밍)](/algorithm%20&%20data%20structure/Dynamic-Programming/)를 확인하길 바란다. 이 문제를 풀 때 필요한 키 핵심은 각 전의 값 + 전전의 값 + 전전전의 값의 경우의 수를 더하면 된다는 것이다. 예를들면, 5인 경우에는 d[4]+d[3] +d[2]일 때이다. 그러면 7+4+2 = 13으로 맞다. 이게 가능한 이유는 앞의 예시에서 d[4]는 앞에 1을 더해주면 5가 되고 d[3]인 경우는 앞에 2를 더해주면 되고 d[2]는 3을 더해주면 된다.
- 이 패턴이 나올 수 있는 이유는 배열 d에 인덱스 값에 알맞는 경우의 수가 저장 되어 있다고 가정하면 입력값이 5인 경우는 (1 + d[4]) + (2 + d[3]) + (3 + d[2]) = d[5]와 같다. 이렇게 풀면 1, 2, 3이 추가 되는 모든 경우의 수를 셀 수 있다.

### 코드:

```cpp
#include <iostream>

using namespace std;

int d[12] = {1, 1, 2}; //Base case n이 0, 1, 2일때 1, 1, 2

int main(){
	int n;
	//입력
	cin >> n;
	for(int i = 0; i < n; i++){
		int temp;
		//입력
		cin >> temp;
		//3부터 시작하여 입력 받은 값까지 모든 경우의 수 쌓아올림
		for(int j = 3; j <= temp; j++){
			d[j] = d[j-1]+d[j-2]+d[j-3]; //전, 전전, 전전전의 값들을 더하면 현재 값이 나온다
		}
		//출력
		cout<<d[temp]<<endl;
	}
}
```